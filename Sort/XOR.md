# 异或运算

可以记为无进位运算

几个性质：

* 0异或N等于N
* N异或N等于0
* 满足交换律和结合律

#### 如何不用额外变量交换两个数（使用以上几个性质可以很好理解）

```java
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

需要注意的是，要交换的两个数不能是存在于同一内存地址的数，N^N=0会导致最后变为0。

#### 一个数组中有一个数出现了奇数次，其余数都出现了偶数次，找到这个出现奇数次的数

利用性质，用0去依次异或，偶数次的数会变成0，最终剩下的数就是要找的出现奇数次的数。

#### 提取一个int类型的数最右侧的1

用这个数和他的相反数与操作即可。观察二进制形式即可。

#### 一个数组中有两种数出现了奇数次，其余数都出现了偶数次，找到这两种出现奇数次的数

先使用0去依次异或，得到的数必然是这两种数异或的结果。获取得到的数最右侧的1，以这个1为区分，再拿一个0去依次与数组中每个最右侧的1等于刚获取到的1的数异或，最终得到的数就是这两种数其中的一个，再与先前得到的数异或就得到了另外一个。

代码实现

```java
public static void findOddTimesNum2(int[] arr) {
    int eor = 0;
    int eor2 = 0;
    for (int j : arr) {
        eor ^= j;
    }
    int rightOne = eor & (-eor);
    for (int j : arr) {
        if ((j & rightOne) != 0) {
            eor2 ^= j;
        }
    }
    System.out.println("eor:" + eor + ",eor2:" + eor2);
}
```

#### 一个数组中有一种数出现K次，其他数都出现了M次，M > 1, K < M。找到出现了K次的数，要求，额外空间复杂度O(1)，时间复杂度O(N)

定义一个32位的int数组，用于存放数组中每个数的二进制形式的各个位置上的1的个数。定义一个0用来存放返回的答案。依次遍历，将各个数的二进制形式的各个位置上1的数量累加到定义的数组中。遍历这个数组，判断各个位置上1的个数是否可以对M除尽，如果可以说明出现K次的数此位置上是0，反之为1，同时将此位置同步到返回的答案变量上（使用1<<此位置对应的位数或上答案变量）。最终将记录好的答案返回。

代码实现

```java
public static int KM(int[] arr, int k, int m) {
    int ans = 0;
    int[] t = new int[32];
    for (int j : arr) {
        for (int i = 0; i < 32; i++) {
            t[i] += (j >> i) & 1;
        }
    }
    for (int i = 0; i < 32; i++) {
        if (t[i] % m == 0) {
            continue;
        }
        if (t[i] % m == k) {
            ans |= 1 << i;
        } else {
            return -1;
        }
    }
    return ans;
}
```



#### 上题简单改一下需求，要求存在这样的出现了K次的数就返回，否则返回-1

同上题的分析，需要考虑新出现的边界问题，定义的返回答案变量默认为0，因为0二进制各个位置上的数对M都是除尽的，所以需要在返回答案前判断是否为0，如果是则进行判断给定数组中0的个数是否等于K，根据结果返回0或者-1。

代码实现（仅记录与上题相比新增代码）

```java
if (ans == 0) {
    int count = 0;
    for (int j : arr) {
        if (j == 0) {
            count++;
        }
    }
    if (count != k) {
        return -1;
    }
}
return ans;
```

### 对数器

很重要的练习方式，脱离oj环境自己进行数据生成和测试。